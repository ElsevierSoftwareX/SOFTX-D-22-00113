package es.csic.getsensordata.data_sensors.definition

import android.content.Context

/**
 * Base class for the data sensors hierarchy.
 *
 * Only inherit directly from this class if the sensor does not rely on SensorManager. In that case,
 * use instead ManagedDataSensor. DataSensorProxy is a temporal proxy only for scaffolding purposes.
 *
 * @param context: a valid application context to access different system resources, like the
 * sensor manager, the strings, etc.
 * @param type: type of data sensor the instance of the class will represent. It will allow the
 * users of this class to identify the kind of information it can get from the data sensor.
 * @param updateInterval: how often will the data sensor offer information regarding its status.
 *
 * TODO: identify the units used when measuring time. As a rule of thumb, it seems `Long` implies
 *  nanoseconds, while `Double` implies second. Also, it a value is multiplied by `1e-9` it is
 *  converting nanoseconds to seconds.
 *
 * WARNING: take this documentation with a grain of salt as it is a work in progress, maybe some
 *  changes are needed.
 */
abstract class DataSensor(
    val context: Context,
    val type: DataSensorType,
    val updateInterval: Double
) {
    var counter: Long = 0 // number of times the data sensor has changed its status
    var epoch: Long = 0 // timestamp, in nanoseconds, when the data sensor started working
        set(value) {
            field = value // when set, the fields bellow are restarted
            previousSensorTimestampInSeconds = 0.0
            previousSecondsFromEpoch = 0.0
        }
    var previousSensorTimestampInSeconds: Double = 0.0 // last time this sensor was used
    var previousSecondsFromEpoch: Double = 0.0 // last time this sensor updated its status
    var measurementFrequency: Float = 0.0f // how frequently should the sensor report its status

    abstract val isAvailable: Boolean // is the sensor available in this device?
    abstract val offersExtendedStatus: Boolean // does the sensor offer extended status information?

    /**
     * Register the listener of this class so its can be notified when something of interest
     * happens. Do any other actions needed to connect to the underlying data sensor.
     *
     * Best suited to be called in an activity's onCreate() method.
     *
     * @param listener: reference to the listener of the events generated by this class, not by
     * `SensorManager`.
     */
    open fun connect(listener: DataSensorEventListener) {
        this.listener = listener
    }

    /**
     * Unregister the listener of this class. Do any other actions needed to connect to the
     * underlying data sensor.
     *
     * Best suited to be called in an activity's onDestroy() method.
     */
    open fun disconnect() {
        this.listener = null
    }

    /**
     * Ideally, data sensor events will start being fired after this method is called. Best suited
     * to be called in an activity's onResume() method.
     */
    abstract fun startReading()

    /**
     * Ideally, data sensor events will stop being fired after this method is called. Best suited
     * to be called in an activity's onPause() method.
     */
    abstract fun stopReading()

    /**
     * Get the prefix this sensor should include every time its information is going to be shown or
     * stored.
     */
    open fun getPrefix(): String {
        return type.prefix
    }

    /**
     * Get the name of the sensor.
     */
    abstract fun getName(): String

    /**
     * Get the prefix of the sensor and append its name.
     *
     * This is the preferred method of getting the details of the sensor for any kind of header.
     */
    open fun getDescription(): String =
        """
            | ${getPrefix()}: ${getName()}
        """.trimMargin()

    /**
     * Get the features of the sensor.
     */
    open fun getFeatures(): String =
        ""

    /**
     * Get the current status of the sensor, formatted to show in the screen while the app is
     * being used.
     */
    abstract fun getStatusForScreen(): String

    /**
     * Get the current extended status of the sensor, formatted to show in the screen while the app
     * is being used.
     *
     * Not every sensor offers extended information. Check the property `offersExtendedStatus` to
     * know if this method could provide information.
     */
    abstract fun getExtendedStatusForScreen(): String

    /**
     * Get the current status of the sensor, formatted to be stored in a log file.
     */
    abstract fun getStatusForLog(): String

    /**
     * Get the current status of the sensor, formatted for the destination passed as a parameter.
     *
     * This is the preferred way of getting the status of the sensor.
     *
     * @param destination: where is the status going to be shown (screen or log).
     */
    fun getStatus(destination: DataSensorStatusDestination): String {
        return when (destination) {
            DataSensorStatusDestination.Screen -> getStatusForScreen()
            DataSensorStatusDestination.Log -> getStatusForLog()
        }
    }

    /**
     * Get the timestamp stored in the event passed as parameter, in seconds.
     *
     * @param event: the event that fired the need to get this sensor status.
     *
     * @return event timestamp in seconds.
     */
    fun getEventTimestampInSeconds(event: DataSensorEvent?): Double =
        event!!.timestamp.toDouble() * 1e-9

    /**
     * Get the number of seconds since it started working, in seconds.
     *
     * @return sensor timestamp in seconds.
     */
    fun getSecondsFromEpoch(): Double {
        // Get current system time in nanoseconds, as this is more precise
        val systemNanoTime = System.nanoTime()
        // Make sure time difference from epoch is positive
        val timestampInNanoseconds: Long = if (systemNanoTime >= epoch) {
            systemNanoTime - epoch
        } else {
            systemNanoTime - epoch + Long.MAX_VALUE
        }
        // Transform nanoseconds to seconds
        return timestampInNanoseconds.toDouble() * 1e-9
    }

    // region Listener

    /**
     * Events that the listener can subscribe to.
     */
    interface DataSensorEventListener {
        // The data sensor was able to connect
        fun onDataSensorConnected(dataSensor: DataSensor)
        // The data sensor was disconnected
        fun onDataSensorDisconnected(dataSensor: DataSensor)
        // The data sensor's status changed
        fun onDataSensorChanged(dataSensor: DataSensor)
    }

    var listener: DataSensorEventListener? = null // reference to object subscribed to the events

    // endregion

    // region Comparison

    /**
     * Overload of the `==` operator.
     *
     * Two instances of the class are considered equal if both are descendants of the `DataSensor`
     * class and its type is the same. Bear this in mind when creating instances of this class.
     *
     * @param other: the other instance we are comparing to this one.
     *
     * @return: `true` of both instances are the same, `false` otherwise.
     */
    override fun equals(other: Any?): Boolean {
        if (other == null) {
            return false
        }

        if (other !is DataSensor) {
            return false
        }

        if (other.type != type) {
            return false
        }

        return true
    }

    /**
     * The hashcode that uniquely identifies each instance of this class.
     *
     * Bear in mind that it relies on the type being different for each different sensor.
     */
    override fun hashCode(): Int {
        return type.hashCode()
    }

    // endregion
}
